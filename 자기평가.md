## 설계

### 1. 아키텍처 선정 기준과 적용

프로젝트 설계를 위해 아키텍처 패턴들을 고려하였습니다. 클린 아키텍처, 헥사고날 아키텍처, 레이어드 아키텍처 등 다양한 아키텍처들 사이에서 레이어드 아키텍처를 선택하였습니다.

### 2. 레이어드 아키텍처

- **계층 분리 및 관심사 분리**:

  - `repositories`: 데이터 접근 로직 (가격 데이터, 백테스트 결과 저장/조회)
  - `services`: 핵심 비즈니스 로직 (백테스트 계산, 데이터 가공)
  - `api`: 외부 인터페이스 제공 (REST API 엔드포인트)
  - `crawlers`: 외부 데이터 수집 로직 (Yahoo Finance 데이터 크롤링)

- **의존성 방향 관리**:
  - 상위 레이어가 하위 레이어에 의존하는 단방향 의존성 원칙 적용
  - 예: service → repository, api → service 방향 의존성 유지

### 3. 도메인 주도 설계(DDD) 접근

백테스트에 요구되는 도메인들을 명확히 모델링하고 분리하고자 노력했습니다.

- **핵심 도메인 모델 설계**:

  - `Portfolio`: 자산 비중, 리밸런싱 로직, 포트폴리오 가치 계산 담당
  - `Strategy`: 모멘텀 기반 자산 선택 및 배분 전략 구현
  - `NAV`: 순자산가치 계산 및 성과 지표 산출

## 책임감

기본적으로 모든 요구사항과 명세에 대해 과제를 넘어 실제 신규 기능구현 task를 할당받았다는 생각으로 서비스의 안정성과 지속가능성을 고려하고자 노력했습니다.

### 1. 데이터 무결성 보장

- **데이터베이스 마이그레이션 관리**:

  - Alembic을 활용한 체계적인 스키마 변경 관리

- **상수 및 환경 변수 관리**:
  - ETF 티커, DB 연결 정보 등 상수화를 통한 코드 전반의 일관성 확보
  - `.env` 파일을 통한 환경별 설정 분리로 개발/운영 환경 전환 용이성 제공

### 2. 백테스트 계산의 정확성 보장

- **테스트 코드 도입**:

  - Risk-off 조건(TIP 수익률 음수 시나리오)에 대한 테스트 케이스 작성으로
  - 모멘텀 계산 및 리밸런싱의 정확성 검증

- **엣지 케이스 처리**:
  - 데이터 부족 상황(계산 기간보다 짧은 데이터)에 대한 예외 처리
  - 거래일/비거래일 구분 로직의 정확성 확보

### 3. 배포 및 운영 고려

- **Docker 기반 환경 구성**:
  - 개발 환경과 운영 환경의 일관성 보장
  - 컨테이너화를 통한 배포 프로세스 단순화

### 4. 개선 방향

현실적인 시간 이슈로 구현하지 못했지만 실제 서비스에 붙여 유지보수를 지속한다면 다음과 같은 요소들을 고려할 것 같습니다.

- 크롤링 안정성 강화 (재시도 메커니즘, 구조 변경 대응)
- sentry 등 모니터링 및 알림 체계 구축
- API 보안 강화 (인증, 권한 관리, 입력 검증)

## 성능

### 벡터화 연산을 통한 백테스트 성능 개선

백테스트 구현 과정에서 장기간의 데이터를 처리해야함을 알게되었고, 이 중 루프가 불필요한 연산을 발생시킨다 판단하여 계산을 최적화하고자 고민한 끝에 벡터연산을 통해 pandas 라이브러리를 도입하였습니다.
이로 인해 반복마다 메모리 접근과 연산오버헤드가 발생하던 부분을 연속된 메모리 블록에서 처리하고 연산도 C레벨에서 최적화된 연산을 활용할 수 있다는 이점을 가져갈 수 있었습니다.

- **모멘텀 계산 최적화**:

  ```python
  # 벡터화 이전 - 루프 사용 시
  def calculate_momentum_loop(self, prices_df):
      momentum = {}
      for ticker in self.tickers:
          ticker_prices = prices_df[ticker]
          returns = (ticker_prices[-1] / ticker_prices[0]) - 1
          momentum[ticker] = returns
      return momentum

  # 벡터화 후 - pandas 연산 사용
  def calculate_momentum(self, prices_df):
      return (prices_df.iloc[-1] / prices_df.iloc[0] - 1)
  ```

  - **성능 차이가 중요한 이유**:

    1. 백테스트는 보통 5-10년 이상의 일별 데이터를 처리
    2. 매월 리밸런싱 시 5개 ETF의 모멘텀을 계산
    3. 예: 10년 데이터 → 120번의 리밸런싱 → 600번의 모멘텀 계산

  - **예상되는 성능 향상**:

    - 데이터 크기가 클수록 벡터화의 효과가 커짐

  - **실제 영향**:
    - API 응답 시간 단축 (특히 장기 백테스트)
    - 여러 백테스트를 동시에 처리할 때 시스템 부하 감소

## 협업

팀원들과 협업을 고려한 프로젝트가 될 수 있도록 노력했습니다.

### 1. 명확한 프로젝트 구조화

- **직관적인 디렉토리 구조**:
  ```
  app/
  ├── api/        # API 라우터
  ├── services/   # 비즈니스 로직
  ├── models/     # 데이터 모델
  └── utils/      # 유틸리티 함수
  ```
  - 각 디렉토리와 파일명을 직관적으로 작성하여 이해되도록 했습니다.

### 2. 환경 설정 표준화

- **환경 변수 관리**:
  ```bash
  # .env.example
  DB_HOST=localhost
  DB_PORT=5432
  DB_NAME=backtest
  DB_USER=backtest
  DB_PASSWORD=backtest
  ```
  - `.env.example` 파일을 통해 필요한 환경 변수를 명시했습니다.
  - 각 변수의 용도와 예시값 제공으로 설정 과정을 간소화하고자 했습니다.

### 3. 접근성 향상

- **Docker 기반 개발 환경**:

  - 운영체제에 관계없이 동일한 환경을 제공하고자 docker를 도입했습니다.
  - 도커 도입 이전에는 환경설정부터 실행까지 최소 5개 이상의 스크립트를 실행했습니다.
  - `docker-compose up` 한 번으로 전체 서비스를 실행할 수 있도록 하였습니다.
  - PostgreSQL 등 외부 의존성 자동 설정을 통해 번거로운 설정을 줄일 수 있도록 했습니다.

- **상세한 README 작성**:
  - 프로젝트 설정부터 실행까지 단계별로 가이드를 제공하여 처음보는 팀원도 이해하고 실행할 수 있도록 작성하고자 하였습니다.
  - fastAPI 엔드포인트에서 제공되는 api 문서화 주소 명시를 통해 api 테스트를 진행할 수 있도록 하였습니다.
